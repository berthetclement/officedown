# sections ----

#' @title section
#'
#' @description Add a section as a block output in an R
#' Markdown document. A section affects preceding paragraphs
#' or tables.
#'
#' @details
#' A section starts at the end of the previous section (or the beginning of
#' the document if no preceding section exists), and stops where the section is declared.
#' @param w,h width and height in inches of the section page. This will
#' be ignored if the default section (of the `reference_docx` file)
#' already has width and height.
#' @export
#' @rdname sections
#' @name sections
block_section_continuous <- function( ){
  str <- "<w:p><w:pPr><w:sectPr><w:officedown/><w:type w:val=\"continuous\"/></w:sectPr></w:pPr></w:p>"
  class(str) <- "ooxml"
  str
}

#' @export
#' @rdname sections
block_section_landscape <- function( w = 21 / 2.54, h = 29.7 / 2.54 ){
  w = w * 20 * 72
  h = h * 20 * 72
  pgsz_str <- "<w:pgSz w:orient=\"landscape\" w:w=\"%.0f\" w:h=\"%.0f\"/>"
  pgsz_str <- sprintf(pgsz_str, h, w )
  str <- sprintf( "<w:p><w:pPr><w:sectPr><w:officedown/>%s</w:pPr></w:p>", pgsz_str)
  class(str) <- "ooxml"
  str
}

#' @export
#' @rdname sections
block_section_portrait <- function( w = 21 / 2.54, h = 29.7 / 2.54 ){
  w = w * 20 * 72
  h = h * 20 * 72
  pgsz_str <- "<w:pgSz w:orient=\"portrait\" w:w=\"%.0f\" w:h=\"%.0f\"/>"
  pgsz_str <- sprintf(pgsz_str, w, h )
  str <- sprintf( "<w:p><w:pPr><w:sectPr><w:officedown/>%s</w:pPr></w:p>", pgsz_str)
  class(str) <- "ooxml"
  str
}

#' @export
#' @param widths columns widths in inches. If 3 values, 3 columns
#' will be produced.
#' @param space space in inches between columns.
#' @param sep if TRUE a line is separating columns.
#' @rdname sections
block_section_columns <- function(widths = c(2.5,2.5), space = .25, sep = FALSE){

  widths <- widths * 20 * 72
  space <- space * 20 * 72

  columns_str_all_but_last <- sprintf("<w:col w:w=\"%.0f\" w:space=\"%.0f\"/>",
                                      widths[-length(widths)], space)
  columns_str_last <- sprintf("<w:col w:w=\"%.0f\"/>",
                              widths[length(widths)])
  columns_str <- c(columns_str_all_but_last, columns_str_last)

  if( length(widths) < 2 )
    stop("length of widths should be at least 2", call. = FALSE)

  columns_str <- sprintf("<w:cols w:num=\"%.0f\" w:sep=\"%.0f\" w:space=\"%.0f\" w:equalWidth=\"0\">%s</w:cols>",
                         length(widths), as.integer(sep), space, paste0(columns_str, collapse = "") )

  str <- paste0( "<w:p>",
                 "<w:pPr><w:sectPr><w:officedown/>",
                 "<w:type w:val=\"continuous\"/>",
                 columns_str, "</w:sectPr></w:pPr></w:p>")
  class(str) <- "ooxml"
  str
}

#' @export
#' @title add a column break
#' @description add a column break as a chunk output in an R
#' Markdown document. A column break is a code inserted in a
#' paragraph the tells Word where to end the current column
#' and begin the next.
#' @seealso [sections()]
chunk_column_break <- function(){
  str <- "<w:r><w:br w:type=\"column\"/></w:r>"
  class(str) <- "ooxml_chunk"
  str
}




# misc ----

#' @export
#' @title add a page break
#' @description add a page break as a chunk output in an R
#' Markdown document. A page break is a code inserted in a paragraph
#' that tells Word where to end the current page and begin the next.
chunk_page_break <- function(){

  str <- "<w:r><w:br w:type=\"page\"/></w:r>"
  class(str) <- "ooxml_chunk"
  str
}

#' @export
#' @title pour the content of a docx file
#' @description Pour the content of a docx file in the resulting docx
#' generated by the main R Markdown document.
#' @param docx_file external docx file path
block_pour_docx <- function(docx_file){
  str <- paste0("<w:altChunk r:id=\"", docx_file, "\"/>")
  class(str) <- "ooxml"
  str
}

#' @export
#' @title add a table of content
#' @description add a table of content as a block output in an R
#' Markdown document.
#'
#' @param level max title level of the table
#' @param style optional. style in the document that will be used to build entries of the TOC.
#' @param separator optional. Some configurations need "," (i.e. from Canada) separator instead of ";"
block_toc <- function( level = 3, style = NULL, separator = ";"){

  if( is.null( style )){
    str <- paste0("<w:p>", "<w:pPr/>",
                  "<w:r><w:fldChar w:fldCharType=\"begin\" w:dirty=\"true\"/></w:r>",
                  "<w:r><w:instrText xml:space=\"preserve\" w:dirty=\"true\">TOC \u005Co &quot;1-%.0f&quot; \u005Ch \u005Cz \u005Cu</w:instrText></w:r>",
                  "<w:r><w:fldChar w:fldCharType=\"end\" w:dirty=\"true\"/></w:r>",
                  "</w:p>")
    str <- sprintf(str, level)
  } else {
    str <- paste0("<w:p>", "<w:pPr/>",
                  "<w:r><w:fldChar w:fldCharType=\"begin\" w:dirty=\"true\"/></w:r>",
                  "<w:r><w:instrText xml:space=\"preserve\" w:dirty=\"true\">TOC \u005Ch \u005Cz \u005Ct \"%s%s1\"</w:instrText></w:r>",
                  "<w:r><w:fldChar w:fldCharType=\"end\" w:dirty=\"true\"/></w:r>",
                  "</w:p>")
    str <- sprintf(str, style, separator)
  }

  class(str) <- "ooxml"
  str
}

#' @export
#' @title add settings for a paragraph
#' @description add settings for a paragraph into a Word document.
#'
#' @param align text alignment - a single character value, expected value
#' is one of 'left', 'right', 'center', 'justify'.
#' @param paddings a named list(b for bottom, t for top, l for left and r for right)
#' containing paragraph paddings - 0 or positive integer value.
#' @param border_widths a named list(b for bottom, t for top, l for left and r for right)
#' containing border widths - 0 or positive integer value.
#' @param border_colors a named list(b for bottom, t for top, l for left and r for right)
#' containing border colors - 0 or positive integer value.
#' @param border_styles a named list(b for bottom, t for top, l for left and r for right)
#' containing border styles. Expected values are "none" or "solid" or "dotted" or "dashed".
#' @param shading shading color - a single character value specifying
#' a valid color (e.g. "#000000" or "black").
#' @examples
#' add_paragraph_settings(paddings = list(t = 120, b = 20),
#'   border_widths = list(b = 5) )
add_paragraph_settings <- function( align = "left",
                                    paddings = list(),
                                    border_widths = list(),
                                    border_colors = list(),
                                    border_styles = list(),
                                    shading = "transparent" ){

  border_widths <- modifyList(list(t = 0, b = 0, l = 0, r = 0), border_widths)
  border_colors <- modifyList(list(t = "black", b = "black", l = "black", r = "black"), border_colors)
  border_styles <- modifyList(list(t = "solid", b = "solid", l = "solid", r = "solid"), border_styles)

  borders <- mapply(border_settings, border_colors, border_styles, border_widths, SIMPLIFY = FALSE)
  x <- paragraph_settings(align = align, paddings = paddings,
                          borders = borders, shading = shading)
  str <- format_paragraph_settings(x, type = "docx")
  class(str) <- "ooxml_chunk"
  str
}

#' @export
#' @title add text and associate it with a character style name.
#' @description Character styles can be applied to individual chunk of text.
#' The function is creating a chunk of text associated with an existing
#' character style name located in the document used as base document.
#' @param str chunk of text
#' @param style a character style name
chunk_text_stylenamed <- function( str, style ){

  if(missing(str)){
    stop("argument 'str' is missing")
  }
  if(missing(style)){
    stop("argument 'style' is missing")
  }

  str <- paste0("<w:r>",
                sprintf("<w:rPr><w:rStyle w:chunk_style=\"%s\"/></w:rPr>", style),
                sprintf("<w:t xml:space=\"preserve\">%s</w:t>", str),
                "</w:r>")
  class(str) <- "ooxml_chunk"
  str
}

#' @export
#' @title styled text
#'
#' @description Character styles can be applied to individual chunk of text.
#' The function is creating a chunk of text associated with formatting
#' defined by several arguments.
#' @param str text
#' @param color font color - a single character value specifying
#' a valid color (e.g. "#000000" or "black").
#' @param size font size (in point) - 0 or positive integer value.
#' @param bold is bold
#' @param italic is italic
#' @param underlined is underlined
#' @param font single character value specifying font name.
#' @param valign single character value specifying font vertical alignments.
#' Expected value is one of the following : default `'baseline'`
#' or `'subscript'` or `'superscript'`
#' @param shading shading color - a single character value specifying
#' a valid color (e.g. "#000000" or "black").
#' @examples
#' chunk_styled_text("test test", color = "red", bold = TRUE)
chunk_styled_text <- function( str, color = NULL, size = NULL,
                               bold = FALSE, italic = FALSE, underlined = FALSE,
                               font = NULL,
                               valign = "baseline",
                               shading = "transparent" ){

  if(missing(str)){
    stop("argument 'str' is missing")
  }

  fp <- text_style(color = color, size = size,
               bold = bold, italic = italic, underlined = underlined,
               font = font,
               valign = valign,
               shading = shading)
  str <- paste0("<w:r>",
                format_text_style_docx(fp),
                sprintf("<w:t xml:space=\"preserve\">%s</w:t>", str),
                "</w:r>")
  class(str) <- "ooxml_chunk"
  str
}

#' @title add a seqfield
#' @description add a seqfield as a chunk output in an R
#' Markdown document. A seqfield is a placeholder for data
#' that can change, and it instructs Word to insert computed
#' values into a document automatically.
#'
#' @param str code for seq field
#' @param style a character style name
#' @export
chunk_seqfield <- function( str, style ){
  xml_elt_1 <- paste0("<w:r>",
                      sprintf("<w:rPr><w:rStyle w:chunk_style=\"%s\"/></w:rPr>", style),
                      "<w:fldChar w:fldCharType=\"begin\" w:dirty=\"true\"/>",
                      "</w:r>")
  xml_elt_2 <- paste0("<w:r>",
                      sprintf("<w:rPr><w:rStyle w:chunk_style=\"%s\"/></w:rPr>", style),
                      sprintf("<w:instrText xml:space=\"preserve\" w:dirty=\"true\">%s</w:instrText>", str ),
                      "</w:r>")
  xml_elt_3 <- paste0("<w:r>",
                      sprintf("<w:rPr><w:rStyle w:chunk_style=\"%s\"/></w:rPr>", style),
                      "<w:fldChar w:fldCharType=\"end\" w:dirty=\"true\"/>",
                      "</w:r>")
  str <- paste0(xml_elt_1, xml_elt_2, xml_elt_3)
  class(str) <- "ooxml_chunk"
  str
}


